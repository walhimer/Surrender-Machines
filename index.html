<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Surrender Machines — Mark Walhimer</title>

  <!-- p5.js via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/p5.min.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&family=IBM+Plex+Mono:wght@300;400&display=swap" rel="stylesheet" />

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --black:   #0a0a0a;
      --offwhite: #f0ede6;
      --dim:      #888880;
      --rule:     #2a2a2a;
      --accent:   #c8a882;
    }

    html { scroll-behavior: smooth; }

    body {
      background: var(--black);
      color: var(--offwhite);
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-weight: 300;
      line-height: 1.6;
      min-height: 100vh;
    }

    /* ── HEADER ──────────────────────────────────────────────── */
    header {
      max-width: 900px;
      margin: 0 auto;
      padding: 72px 40px 48px;
      border-bottom: 1px solid var(--rule);
    }

    .kicker {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      font-weight: 300;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--dim);
      margin-bottom: 28px;
    }

    h1 {
      font-size: clamp(42px, 7vw, 80px);
      font-weight: 300;
      line-height: 1.05;
      letter-spacing: -0.02em;
      margin-bottom: 32px;
    }

    h1 em {
      font-style: italic;
      color: var(--accent);
    }

    .lede {
      font-size: clamp(18px, 2.2vw, 22px);
      font-weight: 300;
      line-height: 1.65;
      color: var(--offwhite);
      max-width: 660px;
      margin-bottom: 24px;
    }

    .lede strong {
      font-weight: 400;
      color: var(--accent);
    }

    .thesis {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 12px;
      font-weight: 300;
      color: var(--dim);
      border-left: 1px solid var(--rule);
      padding-left: 20px;
      line-height: 1.8;
      max-width: 600px;
      margin-top: 28px;
    }

    /* ── INSTRUCTION BAR ─────────────────────────────────────── */
    .instruction-bar {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px 40px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid var(--rule);
    }

    .instruction-bar .dot {
      width: 6px;
      height: 6px;
      background: var(--accent);
      border-radius: 50%;
      flex-shrink: 0;
      animation: pulse 2.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50%       { opacity: 0.3; }
    }

    .instruction-bar p {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11.5px;
      font-weight: 300;
      color: var(--dim);
      letter-spacing: 0.04em;
    }

    .instruction-bar p span {
      color: var(--offwhite);
    }

    /* ── MACHINE STAGE ───────────────────────────────────────── */
    #machine-stage {
      width: 100%;
      background: #111;
      position: relative;
      border-bottom: 1px solid var(--rule);
    }

    /* p5 canvas fills width, sliders overlaid */
    #machine-stage canvas {
      display: block;
      width: 100% !important;
      max-width: 1000px;
      margin: 0 auto;
    }

    /* Custom slider panel */
    #controls {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: min(900px, 94vw);
      display: grid;
      grid-template-columns: 1fr 1fr 1fr auto;
      gap: 12px;
      pointer-events: none;
      z-index: 10;
      align-items: stretch;
    }

    .ctrl {
      pointer-events: all;
      background: rgba(10,10,10,0.82);
      border: 1px solid var(--rule);
      padding: 12px 14px;
      backdrop-filter: blur(6px);
    }

    .ctrl-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      font-weight: 400;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--dim);
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .ctrl-label span.val {
      color: var(--offwhite);
      font-size: 11px;
    }

    .ctrl input[type=range] {
      display: block !important;
      width: 100%;
      height: 3px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--rule);
      border-radius: 0;
      outline: none;
      cursor: pointer;
    }

    .ctrl input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 13px;
      height: 13px;
      border-radius: 50%;
      background: var(--offwhite);
      cursor: pointer;
      transition: background 0.15s;
    }

    .ctrl input[type=range]::-webkit-slider-thumb:hover {
      background: var(--accent);
    }

    .ctrl-desc {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 9.5px;
      color: #555;
      margin-top: 6px;
      letter-spacing: 0.06em;
    }

    /* Fullscreen button — lives inside #controls grid */
    #fs-btn {
      pointer-events: all;
      background: rgba(10,10,10,0.82);
      border: 1px solid var(--rule);
      color: var(--dim);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 12px 14px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      transition: color 0.15s, border-color 0.15s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      white-space: nowrap;
    }

    #fs-btn:hover { color: var(--offwhite); border-color: var(--accent); }

    #fs-btn svg {
      width: 14px;
      height: 14px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.5;
    }

    /* Close button visible only in fullscreen — top right corner */
    #fs-close, #fs-refresh {
      display: none;
      position: fixed;
      top: 20px;
      z-index: 1010;
      background: rgba(10,10,10,0.85);
      border: 1px solid var(--rule);
      color: var(--offwhite);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 10px 18px;
      cursor: pointer;
      backdrop-filter: blur(8px);
      transition: color 0.15s, border-color 0.15s;
      align-items: center;
      gap: 8px;
    }

    #fs-close  { right: 20px; }
    #fs-refresh { right: 110px; }

    #fs-close:hover, #fs-refresh:hover { border-color: var(--accent); color: var(--accent); }

    #machine-stage.is-fullscreen #fs-close,
    #machine-stage.is-fullscreen #fs-refresh {
      display: flex;
    }

    #fs-btn svg {
      width: 12px;
      height: 12px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.5;
    }

    /* Fullscreen overlay mode */
    #machine-stage.is-fullscreen {
      position: fixed !important;
      inset: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 1000;
      background: #111;
    }

    #machine-stage.is-fullscreen canvas {
      width: 100vw !important;
      height: 100vh !important;
      max-width: none !important;
    }

    #machine-stage.is-fullscreen #controls {
      top: 20px;
    }

    /* zero-state hint inside canvas area */
    #zero-hint {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.6s ease;
      z-index: 5;
    }

    #zero-hint.visible { opacity: 1; }

    #zero-hint p {
      font-family: 'Cormorant Garamond', serif;
      font-style: italic;
      font-size: clamp(16px, 2.5vw, 24px);
      color: #333;
      letter-spacing: 0.06em;
    }

    /* ── ORBIT NOTE ──────────────────────────────────────────── */
    .orbit-note {
      max-width: 900px;
      margin: 0 auto;
      padding: 14px 40px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10.5px;
      color: var(--dim);
      border-bottom: 1px solid var(--rule);
      letter-spacing: 0.06em;
    }

    /* ── PROCESS SECTION ─────────────────────────────────────── */
    .section {
      max-width: 900px;
      margin: 0 auto;
      padding: 64px 40px;
    }

    .section-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--dim);
      margin-bottom: 36px;
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .section-label::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--rule);
    }

    .process-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 1px;
      background: var(--rule);
      border: 1px solid var(--rule);
    }

    .process-step {
      background: var(--black);
      padding: 28px 22px;
    }

    .step-num {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      color: var(--dim);
      letter-spacing: 0.14em;
      margin-bottom: 14px;
    }

    .step-title {
      font-size: 20px;
      font-weight: 300;
      margin-bottom: 10px;
      line-height: 1.2;
    }

    .step-desc {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      color: var(--dim);
      line-height: 1.7;
    }

    /* ── CONCEPT BODY ────────────────────────────────────────── */
    .concept-body {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 48px;
      align-items: start;
    }

    @media (max-width: 620px) {
      .concept-body { grid-template-columns: 1fr; }
      #controls { grid-template-columns: 1fr 1fr; }
      #controls #fs-btn { grid-column: 1 / -1; flex-direction: row; justify-content: center; }
    }

    .concept-body p {
      font-size: clamp(17px, 2vw, 19px);
      line-height: 1.72;
      color: #c8c4bc;
      margin-bottom: 18px;
    }

    .concept-body p:last-child { margin-bottom: 0; }

    .pull-quote {
      font-size: clamp(22px, 3vw, 30px);
      font-style: italic;
      font-weight: 300;
      line-height: 1.35;
      color: var(--offwhite);
      border-left: 2px solid var(--accent);
      padding-left: 28px;
    }

    /* ── RULE ────────────────────────────────────────────────── */
    hr.divider {
      border: none;
      border-top: 1px solid var(--rule);
      margin: 0;
    }

    /* ── FOOTER ──────────────────────────────────────────────── */
    footer {
      max-width: 900px;
      margin: 0 auto;
      padding: 48px 40px 80px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 32px;
      align-items: end;
      border-top: 1px solid var(--rule);
    }

    .author-block p {
      font-size: 16px;
      color: #888;
      line-height: 1.65;
    }

    .author-block strong {
      display: block;
      font-size: 20px;
      font-weight: 400;
      color: var(--offwhite);
      margin-bottom: 6px;
    }

    .footer-links {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
    }

    .footer-links a {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10.5px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--dim);
      text-decoration: none;
      transition: color 0.15s;
    }

    .footer-links a:hover { color: var(--accent); }

    @media (max-width: 540px) {
      footer { grid-template-columns: 1fr; }
      .footer-links { align-items: flex-start; }
      header, .instruction-bar, .orbit-note, .section, footer { padding-left: 24px; padding-right: 24px; }
      #controls { gap: 8px; top: 12px; }
    }
  </style>
</head>

<body>

<!-- ── HEADER ──────────────────────────────────────────────────────── -->
<header>
  <p class="kicker">Generative Art &nbsp;/&nbsp; Interactive System &nbsp;/&nbsp; 2025–2026</p>
  <h1>Surrender<br /><em>Machines</em></h1>
  <p class="lede">
    Three human emotions — <strong>anger, ego, and attachment</strong> — determine
    the structure of surrender. Modify the machine to see the outcomes.
  </p>
  <div class="thesis">
    Marcel Duchamp's bachelors desire the bride but the circuit never closes.<br />
    Here the circuit can close — but only when the machine goes quiet.<br />
    You cannot build your way to surrender. You can only stop building.
  </div>
</header>

<!-- ── INSTRUCTION BAR ─────────────────────────────────────────────── -->
<div class="instruction-bar">
  <div class="dot"></div>
  <p>Adjust the sliders. Push them high. &nbsp;<span>The machine decides when it stops.</span></p>
</div>

<!-- ── MACHINE STAGE ───────────────────────────────────────────────── -->
<div id="machine-stage">

  <!-- Custom controls overlay -->
  <div id="controls">
    <div class="ctrl" id="ctrl-anger">
      <div class="ctrl-label">Anger <span class="val" id="val-anger">50</span></div>
      <input type="range" id="sl-anger" min="0" max="100" value="50" />
      <div class="ctrl-desc">gears break</div>
    </div>
    <div class="ctrl" id="ctrl-ego">
      <div class="ctrl-label">Ego <span class="val" id="val-ego">50</span></div>
      <input type="range" id="sl-ego" min="0" max="100" value="50" />
      <div class="ctrl-desc">static interference</div>
    </div>
    <div class="ctrl" id="ctrl-attachment">
      <div class="ctrl-label">Attachment <span class="val" id="val-attachment">50</span></div>
      <input type="range" id="sl-attachment" min="0" max="100" value="50" />
      <div class="ctrl-desc">static residue</div>
    </div>

    <button id="fs-btn" title="Toggle fullscreen" aria-label="Toggle fullscreen">
      <svg id="fs-icon-open" viewBox="0 0 24 24">
        <polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/>
        <line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>
      </svg>
      Fullscreen
    </button>
  </div>

  <!-- Buttons only visible in fullscreen -->
  <button id="fs-refresh" aria-label="New machine">
    <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" fill="none" stroke-width="1.5">
      <polyline points="23 4 23 10 17 10"/>
      <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
    </svg>
    New Machine
  </button>
  <button id="fs-close" aria-label="Exit fullscreen">
    <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" fill="none" stroke-width="1.5">
      <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
    </svg>
    Exit
  </button>

  <div id="zero-hint">
    <p>The circuit is open.</p>
  </div>

</div>

<!-- ── ORBIT NOTE ──────────────────────────────────────────────────── -->
<p class="orbit-note">↳ Drag to orbit &nbsp;·&nbsp; scroll to zoom &nbsp;·&nbsp; the machine runs on its own time</p>

<hr class="divider" />

<!-- ── PROCESS ─────────────────────────────────────────────────────── -->
<div class="section">
  <p class="section-label">Process</p>
  <div class="process-grid">
    <div class="process-step">
      <p class="step-num">01</p>
      <p class="step-title">Schematic</p>
      <p class="step-desc">Technical drawing. TENSION, STRUCTURE, THRESHOLD. The machine before it has a body.</p>
    </div>
    <div class="process-step">
      <p class="step-num">02</p>
      <p class="step-title">Wireframe</p>
      <p class="step-desc">Pure structure, no surface. The bachelor machine before desire gives it weight.</p>
    </div>
    <div class="process-step">
      <p class="step-num">03</p>
      <p class="step-title">Sculpture</p>
      <p class="step-desc">Transparent casing. The inner mechanism exposed. You can see everything and change nothing.</p>
    </div>
    <div class="process-step">
      <p class="step-num">04</p>
      <p class="step-title">Generative</p>
      <p class="step-desc">Live. Anger breaks the gears. Ego produces static. Attachment holds on. The machine stops when it decides to.</p>
    </div>
  </div>
</div>

<hr class="divider" />

<!-- ── CONCEPT ─────────────────────────────────────────────────────── -->
<div class="section">
  <p class="section-label">Concept</p>
  <div class="concept-body">
    <div>
      <p>
        We all need to learn surrender. Not defeat — surrender. The conscious decision
        to stop fighting what cannot be changed. We all have frustrations. We all have
        things that bother us, people that irritate us, noise we didn't ask for.
        And often the best thing — the only useful thing — is acceptance.
      </p>
      <p>
        Acceptance is not passive. It is a choice you have to make, sometimes many
        times in a single day. The machine reminds you of that. It runs on anger, ego,
        and attachment. Turn them up and watch what happens. Turn them down and watch
        what happens. The machine shows you the structure of the problem.
      </p>
      <p>
        But the machine cannot surrender for you. That is the point. There are many
        things in life we simply have to accept. There is no other choice that leads
        anywhere worth going. This machine exists to make that visible.
      </p>
    </div>
    <div>
      <p class="pull-quote">
        "Surrender is not the absence of feeling. It is the conscious decision to stop letting feeling decide."
      </p>
    </div>
  </div>
</div>

<hr class="divider" />

<!-- ── FOOTER ──────────────────────────────────────────────────────── -->
<footer>
  <div class="author-block">
    <p><strong>Mark Walhimer</strong>
      Museum planner, industrial designer, generative artist.<br />
      Author of <em>Museums 101</em> and <em>Designing Museum Experiences</em>.<br />
      Generative works on Objkt.com. Prix Ars Electronica submission 2026.
    </p>
  </div>
  <div class="footer-links">
    <a href="https://medium.com/@markwalhimer" target="_blank" rel="noopener">Medium</a>
    <a href="https://objkt.com" target="_blank" rel="noopener">Objkt</a>
    <a href="https://markwalhimer.com" target="_blank" rel="noopener">markwalhimer.com</a>
  </div>
</footer>


<!-- ══════════════════════════════════════════════════════════════════
     P5.JS SKETCH — embedded inline, driven by custom sliders above
     ══════════════════════════════════════════════════════════════════ -->
<script>
// ── Fullscreen toggle ──────────────────────────────────────────────
const stage    = document.getElementById('machine-stage');
const fsBtn    = document.getElementById('fs-btn');
const fsClose   = document.getElementById('fs-close');
const fsRefresh = document.getElementById('fs-refresh');

fsRefresh.addEventListener('click', () => {
  // Reset all sliders to 50
  _slAnger.value           = 50;
  _slEgo.value             = 50;
  _slAttachment.value      = 50;
  document.getElementById('val-anger').textContent      = 50;
  document.getElementById('val-ego').textContent        = 50;
  document.getElementById('val-attachment').textContent = 50;
  document.getElementById('zero-hint').classList.remove('visible');
  // Signal sketch to regenerate
  window._newSeedRequested = true;
});

function enterFullscreen() {
  stage.classList.add('is-fullscreen');
  document.body.style.overflow = 'hidden';
  setTimeout(() => window.dispatchEvent(new Event('resize')), 30);
  // Try native fullscreen API
  if (stage.requestFullscreen) stage.requestFullscreen().catch(() => {});
}

function exitFullscreen() {
  stage.classList.remove('is-fullscreen');
  document.body.style.overflow = '';
  setTimeout(() => window.dispatchEvent(new Event('resize')), 30);
  if (document.fullscreenElement) document.exitFullscreen().catch(() => {});
}

fsBtn.addEventListener('click', enterFullscreen);
fsClose.addEventListener('click', exitFullscreen);

// ESC key also works
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && stage.classList.contains('is-fullscreen')) exitFullscreen();
});

// Sync if native fullscreen exits via browser chrome
document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement && stage.classList.contains('is-fullscreen')) {
    exitFullscreen();
  }
});

const _slAnger      = document.getElementById('sl-anger');
const _slEgo        = document.getElementById('sl-ego');
const _slAttachment = document.getElementById('sl-attachment');

function _getSliderVal(el) { return parseInt(el.value, 10); }

// Update display values & zero-hint
[_slAnger, _slEgo, _slAttachment].forEach((sl, i) => {
  const ids = ['anger','ego','attachment'];
  sl.addEventListener('input', () => {
    document.getElementById('val-' + ids[i]).textContent = sl.value;
    const allZero = _getSliderVal(_slAnger) === 0 &&
                    _getSliderVal(_slEgo) === 0 &&
                    _getSliderVal(_slAttachment) === 0;
    document.getElementById('zero-hint').classList.toggle('visible', allZero);
  });
});
</script>




<script>
// ── SURRENDER MACHINES ────────────────────────────────────────────
//
// Three forces blind us to the connection that was always there.
//
// ANGER      → gears spin out, break, jitter. The machine destroys itself.
// EGO        → sharp static. Bright interference. The signal of self.
// ATTACHMENT → slow dense static. The residue that won't clear.
//
// At 0% each: a simple, working machine. The circuit is open.
// At 65%: peak complexity.
// At 100%: the machine breaks in its own way.
//
// A random timer runs silently — 20s to 5min.
// When it expires, the machine fades to shadow.
// That is surrender arriving at its own time, not yours.

let parts = [];
let seed  = Math.floor(Math.random() * 999999);

let angerVal      = 0.5;
let egoVal        = 0.5;
let attachmentVal = 0.5;

let angerStress      = 0;
let egoStress        = 0;
let attachmentStress = 0;

let gPlatformExtras = 0;
let gColumnCount    = 4;
let gGearCount      = 60;
let gPulleyCount    = 10;
let gRodCount       = 5;

let prevPlatformExtras = -1;
let prevColumnCount    = -1;
let prevGearCount      = -1;
let prevPulleyCount    = -1;
let prevRodCount       = -1;

let machineBuilt = false;

// ── TIMER ─────────────────────────────────────────────────────────
const TIMER_DURATION  = Math.floor(Math.random() * (300 - 120 + 1) + 120) * 1000;
const FADE_DURATION   = 12000;
let   timerStart      = null;
let   shadowAmount    = 0;
let   surrendered     = false;

function richness(val) { return Math.min(val / 0.65, 1.0); }
function stressOf(val) { return Math.max(0, (val - 0.65) / 0.35); }

const sketch = function(p) {

  p.setup = function() {
    const stage = document.getElementById('machine-stage');
    const w = Math.min(stage.offsetWidth, 1000);
    const cnv = p.createCanvas(w, w, p.WEBGL);
    cnv.parent('machine-stage');
    p.pixelDensity(Math.min(window.devicePixelRatio, 2));
    p.angleMode(p.RADIANS);
    p.colorMode(p.HSB, 360, 100, 100, 100);
    p.smooth();
    updateTargets();
    buildMachine();
    machineBuilt = true;
  };

  p.draw = function() {
    if (window._newSeedRequested) {
      window._newSeedRequested = false;
      seed = Math.floor(Math.random() * 999999);
      machineBuilt  = false;
      surrendered   = false;
      shadowAmount  = 0;
      timerStart    = null;
      prevPlatformExtras = -1;
    }

    if (timerStart === null) timerStart = p.millis();
    const elapsed = p.millis() - timerStart;
    if (elapsed >= TIMER_DURATION) {
      shadowAmount = Math.min((elapsed - TIMER_DURATION) / FADE_DURATION, 1.0);
      if (shadowAmount >= 1.0) surrendered = true;
    }

    updateTargets();

    if (!surrendered && (
      gPlatformExtras !== prevPlatformExtras ||
      gColumnCount    !== prevColumnCount    ||
      gGearCount      !== prevGearCount      ||
      gPulleyCount    !== prevPulleyCount    ||
      gRodCount       !== prevRodCount       ||
      !machineBuilt
    )) {
      buildMachine();
      machineBuilt       = true;
      prevPlatformExtras = gPlatformExtras;
      prevColumnCount    = gColumnCount;
      prevGearCount      = gGearCount;
      prevPulleyCount    = gPulleyCount;
      prevRodCount       = gRodCount;
    }

    p.background(0, 0, 100);

    const lightBright = p.lerp(80, 50, shadowAmount);
    p.ambientLight(lightBright);
    if (shadowAmount < 1) {
      p.directionalLight(255, 255, 255,  0.35, -0.4, -1);
      p.directionalLight(180, 180, 255, -0.30,  0.2,  1);
    }

    p.orbitControl();
    p.rotateX(-0.4);
    p.rotateY(0.3);
    p.translate(0, 50, 0);

    const t = p.millis() * 0.001;
    for (let part of parts) { part.update(t); part.draw(t); }

    // ── STATIC OVERLAY ────────────────────────────────────────────
    // Drawn in screen space after the 3D scene
    const staticLevel = Math.max(egoStress, attachmentStress);
    if (staticLevel > 0 && shadowAmount < 1) {
      drawStatic(t, staticLevel);
    }
  };

  // Static: ego = sharp bright sparks, attachment = slow drifting grain
  function drawStatic(t, level) {
    p.push();
    p.camera(0, 0, (p.height / 2.0) / p.tan(p.PI * 30.0 / 180.0), 0, 0, 0, 0, 1, 0);
    p.noLights();
    p.noStroke();

    const W = p.width;
    const H = p.height;

    // EGO STATIC — sharp, bright, white/yellow sparks
    if (egoStress > 0) {
      const egoCount = p.floor(egoStress * egoStress * 1800);
      for (let i = 0; i < egoCount; i++) {
        const sx = p.random(-W / 2, W / 2);
        const sy = p.random(-H / 2, H / 2);
        const sw = p.random(1, p.lerp(1, 5, egoStress));
        const sh = p.random(1, 2);
        const sb = p.random(88, 100);
        const sa = p.random(40, 80) * egoStress;
        // Sharp hue — white to yellow to hot
        const hue = p.random() < 0.6 ? 0 : p.random(45, 60);
        p.fill(hue, p.random() < 0.6 ? 0 : 80, sb, sa);
        p.rect(sx - sw / 2, sy - sh / 2, sw, sh);
      }
    }

    // ATTACHMENT STATIC — slow, denser, grey-brown grain
    if (attachmentStress > 0) {
      const attCount = p.floor(attachmentStress * attachmentStress * 2400);
      // Attachment grain drifts slowly — use noise offset by time
      const driftX = p.noise(t * 0.08) * 80 - 40;
      const driftY = p.noise(t * 0.08 + 100) * 80 - 40;
      for (let i = 0; i < attCount; i++) {
        const sx = p.random(-W / 2, W / 2) + driftX;
        const sy = p.random(-H / 2, H / 2) + driftY;
        const sw = p.random(1, 3);
        const sh = p.random(1, p.lerp(1, 6, attachmentStress));
        const sb = p.random(40, 72);
        const sa = p.random(15, 45) * attachmentStress;
        p.fill(p.random(20, 40), p.random(10, 30), sb, sa);
        p.rect(sx - sw / 2, sy - sh / 2, sw, sh);
      }
    }

    p.pop();
  }

  p.windowResized = function() {
    const stage = document.getElementById('machine-stage');
    const isFS  = stage.classList.contains('is-fullscreen');
    const w = isFS ? window.innerWidth  : Math.min(stage.offsetWidth, 1000);
    const h = isFS ? window.innerHeight : w;
    p.resizeCanvas(w, h);
  };

  function updateTargets() {
    angerVal      = _getSliderVal(_slAnger)      / 100.0;
    egoVal        = _getSliderVal(_slEgo)        / 100.0;
    attachmentVal = _getSliderVal(_slAttachment) / 100.0;

    angerStress      = stressOf(angerVal);
    egoStress        = stressOf(egoVal);
    attachmentStress = stressOf(attachmentVal);

    const rA = richness(angerVal);
    const rE = richness(egoVal);
    const rAt = richness(attachmentVal);

    // Anger → gears (the churning, the breaking)
    gGearCount      = p.floor(p.map(rA,  0, 1, 4,   200));
    // Ego → platforms + columns (structural ambition, the weight of self)
    gPlatformExtras = p.floor(p.map(rE,  0, 1, 0,   3));
    gColumnCount    = p.floor(p.map(rE,  0, 1, 3,   12));
    // Attachment → pulleys + rods (the holding on, the connective tissue)
    gPulleyCount    = p.floor(p.map(rAt, 0, 1, 2,   60));
    gRodCount       = p.floor(p.map(rAt, 0, 1, 1,   20));

    // No gears without columns
    if (gColumnCount < 2) gGearCount = Math.min(gGearCount, 4);

    const allZero = angerVal === 0 && egoVal === 0 && attachmentVal === 0;
    document.getElementById('zero-hint').classList.toggle('visible', allZero);
  }

  function machineFill(x, y, z, baseHue, hueSpread, maxAlpha, t, stress) {
    stress = stress || 0;
    if (shadowAmount >= 1.0) {
      p.fill(0, 0, p.lerp(90, 96, p.noise(x * 0.002, y * 0.002, t * 0.05)), 8);
      return;
    }
    const nx = p.constrain(p.map(x, -600, 600, -1, 1), -1, 1);
    const ny = p.constrain(p.map(y, -600, 600, -1, 1), -1, 1);
    const nz = p.constrain(p.map(z, -600, 600, -1, 1), -1, 1);
    const pf = nx + ny + nz;
    const tf = p.sin(t * 0.9 + pf * 2.5);
    let h    = baseHue + hueSpread * (0.5 * pf + 0.5 * tf);
    h = p.lerp(h, 0, stress * 0.7);
    h = (h % 360 + 360) % 360;
    maxAlpha = p.min(maxAlpha, 85);
    let alpha = p.lerp(maxAlpha * 0.25, maxAlpha, (ny + 1) * 0.5);
    if (stress > 0.5 && p.random() < stress * 0.35) alpha *= p.random(0.1, 0.5);
    const sat = p.lerp(100, 0, shadowAmount);
    const bri = p.lerp(100, 95, shadowAmount);
    alpha     = p.lerp(alpha, 6, shadowAmount);
    p.fill(h, sat, bri, alpha);
  }

  function jitter(stress) {
    if (stress <= 0 || shadowAmount >= 1) return { x: 0, y: 0, z: 0 };
    const m = stress * stress * 120;
    return { x: p.random(-m, m), y: p.random(-m, m), z: p.random(-m, m) };
  }

  function speedMult(stress) {
    return (1 + stress * stress * 7) * p.lerp(1, 0.04, shadowAmount);
  }

  // ── BUILD ──────────────────────────────────────────────────────
  function buildMachine() {
    parts = [];
    p.randomSeed(seed);
    const sf = 1.2;
    const bW = 600 * sf, bD = 600 * sf, bT = 25 * sf;

    parts.push(new BasePlate(0, 0, 0, bW, bT, bD));

    // Extra platforms — ego builds more structure to stand on
    for (let i = 0; i < gPlatformExtras; i++) {
      const w  = bW * p.random(0.5, 1.0);
      const d  = bD * p.random(0.5, 1.0);
      const h  = bT * p.random(0.6, 1.4);
      const px = p.random(-60, 60) * sf;
      const pz = p.random(-60, 60) * sf;
      const py = -p.random(80, 220) * sf;
      parts.push(new BasePlate(px, py, pz, w, h, d));
    }

    const colPositions = [];
    const colH = p.random(140, 220) * sf;
    const colR = p.random(14, 24)   * sf;
    for (let i = 0; i < gColumnCount; i++) {
      const x = p.random(-bW * 0.35, bW * 0.35);
      const z = p.random(-bD * 0.35, bD * 0.35);
      parts.push(new Column(x, -colH / 2 - bT / 2, z, colR, colH));
      colPositions.push(p.createVector(x, -colH, z));
    }

    for (let i = 0; i < gGearCount; i++) {
      const anch  = p.random(colPositions);
      const r     = p.random(40, 80) * sf;
      const thick = p.random(14, 26) * sf;
      const teeth = p.floor(p.random(8, 18));
      const yOff  = p.random(-200, 200);
      const spd   = p.random([-1, 1]) * p.random(0.2, 0.8);
      const Cls   = p.random() < 0.5 ? GearHorizontal : GearVertical;
      parts.push(new Cls(
        anch.x + p.random(-80, 20), anch.y + yOff,
        anch.z + p.random(-20, 20), r, thick, teeth, spd
      ));
    }

    for (let i = 0; i < gPulleyCount; i++) {
      const a = p.random(colPositions), b = p.random(colPositions);
      if (a === b) continue;
      const mid = p5.Vector.add(a, b).mult(0.5);
      const r   = p.random(25, 55) * sf;
      const th  = p.random(10, 18) * sf;
      const spd = p.random([-1, 1]) * p.random(0.4, 1.0);
      parts.push(new PulleyStandalone(mid.x, mid.y + p.random(-40, 40), mid.z, r, th, spd));
    }

    for (let i = 0; i < gRodCount; i++) {
      const a = p.random(colPositions), b = p.random(colPositions);
      if (a === b) continue;
      parts.push(new RodWithAttachments(
        a.x, a.y, a.z, b.x, b.y, b.z,
        p.random(5, 9) * sf, richness(angerVal), richness(attachmentVal)
      ));
    }
  }

  // ── CLASSES ───────────────────────────────────────────────────

  class BasePlate {
    constructor(x, y, z, w, h, d) { this.pos = p.createVector(x, y, z); this.w=w; this.h=h; this.d=d; }
    update() {}
    draw(t) {
      const j = jitter(egoStress);
      p.push();
      p.translate(this.pos.x+j.x, this.pos.y+this.h/2+j.y, this.pos.z+j.z);
      p.noStroke();
      machineFill(this.pos.x, this.pos.y, this.pos.z, 305, 110, 80, t, egoStress);
      p.box(this.w, this.h, this.d);
      p.pop();
    }
  }

  class Column {
    constructor(x, y, z, r, h) { this.pos = p.createVector(x, y, z); this.r=r; this.h=h; }
    update() {}
    draw(t) {
      const j = jitter(egoStress);
      p.push();
      p.translate(this.pos.x+j.x, this.pos.y+j.y, this.pos.z+j.z);
      p.rotateX(p.HALF_PI); p.noStroke();
      machineFill(this.pos.x, this.pos.y, this.pos.z, 320, 90, 78, t, egoStress);
      p.cylinder(this.r, this.h);
      p.pop();
    }
  }

  class GearHorizontal {
    constructor(x, y, z, radius, thickness, teeth, speed) {
      this.pos=p.createVector(x,y,z); this.radius=radius; this.thickness=thickness;
      this.teeth=teeth; this.baseSpeed=speed; this.angle=p.random(p.TWO_PI);
    }
    update(t) { this.angle = this.baseSpeed * speedMult(angerStress) * t; }
    draw(t) {
      const s=angerStress, j=jitter(s);
      p.push();
      p.translate(this.pos.x+j.x, this.pos.y+j.y, this.pos.z+j.z);
      p.rotateY(this.angle); p.noStroke();
      machineFill(this.pos.x, this.pos.y, this.pos.z, 15, 140, 80, t, s);
      p.cylinder(this.radius, this.thickness);
      const tD=this.thickness*1.1, tW=(p.TWO_PI*this.radius)/(this.teeth*4), tH=this.radius*0.12;
      for (let i=0; i<this.teeth; i++) {
        const a=(p.TWO_PI*i)/this.teeth;
        p.push();
        p.translate(p.cos(a)*this.radius, 0, p.sin(a)*this.radius);
        p.rotateY(a);
        machineFill(this.pos.x, this.pos.y, this.pos.z, 30, 130, 82, t, s);
        p.box(tW, tH, tD);
        p.pop();
      }
      p.pop();
    }
  }

  class GearVertical {
    constructor(x, y, z, radius, thickness, teeth, speed) {
      this.pos=p.createVector(x,y,z); this.radius=radius; this.thickness=thickness;
      this.teeth=teeth; this.baseSpeed=speed; this.angle=p.random(p.TWO_PI);
    }
    update(t) { this.angle = this.baseSpeed * speedMult(angerStress) * t; }
    draw(t) {
      const s=angerStress, j=jitter(s);
      p.push();
      p.translate(this.pos.x+j.x, this.pos.y+j.y, this.pos.z+j.z);
      p.rotateX(this.angle); p.noStroke();
      machineFill(this.pos.x, this.pos.y, this.pos.z, 25, 160, 78, t, s);
      p.cylinder(this.radius, this.thickness);
      const tD=this.thickness*1.1, tW=(p.TWO_PI*this.radius)/(this.teeth*4), tH=this.radius*0.12;
      for (let i=0; i<this.teeth; i++) {
        const a=(p.TWO_PI*i)/this.teeth;
        p.push();
        p.translate(0, p.cos(a)*this.radius, p.sin(a)*this.radius);
        p.rotateX(a);
        machineFill(this.pos.x, this.pos.y, this.pos.z, 40, 140, 80, t, s);
        p.box(tW, tH, tD);
        p.pop();
      }
      p.pop();
    }
  }

  class PulleyStandalone {
    constructor(x, y, z, radius, thickness, speed) {
      this.pos=p.createVector(x,y,z); this.radius=radius; this.thickness=thickness;
      this.baseSpeed=speed; this.angle=p.random(p.TWO_PI);
    }
    update(t) { this.angle = this.baseSpeed * speedMult(attachmentStress) * t; }
    draw(t) {
      const s=attachmentStress, j=jitter(s);
      p.push();
      p.translate(this.pos.x+j.x, this.pos.y+j.y, this.pos.z+j.z);
      p.rotateY(this.angle); p.noStroke();
      machineFill(this.pos.x, this.pos.y, this.pos.z, 80, 130, 75, t, s);
      p.cylinder(this.radius, this.thickness*0.5);
      p.push();
      machineFill(this.pos.x, this.pos.y, this.pos.z, 200, 90, 60, t, s);
      p.cylinder(this.radius*0.7, this.thickness*1.2);
      p.pop(); p.pop();
    }
  }

  class RodWithAttachments {
    constructor(x1, y1, z1, x2, y2, z2, radius, gearDensity, pulleyDensity) {
      this.a=p.createVector(x1,y1,z1); this.b=p.createVector(x2,y2,z2);
      this.radius=radius; this.gearDensity=gearDensity; this.pulleyDensity=pulleyDensity;
      this._ct(); this._ba();
    }
    _ct() {
      const dir=p5.Vector.sub(this.b,this.a);
      this.length=dir.mag(); this.mid=p5.Vector.add(this.a,this.b).mult(0.5);
      dir.normalize();
      this.rotY=p.atan2(dir.x,dir.z);
      this.rotX=p.atan2(-dir.y, p.sqrt(dir.z*dir.z+dir.x*dir.x));
    }
    _ba() {
      this.attachments=[];
      const eff=this.pulleyDensity<=0?0:this.gearDensity;
      const nG=p.floor(p.map(eff,0,1,0,8)), nP=p.floor(p.map(this.pulleyDensity,0,1,0,8));
      const total=nG+nP; if (!total) return;
      let gc=0, pc=0, idx=0;
      while (idx<total) {
        let kind;
        if (gc<nG && pc<nP) kind=p.random(nG-gc+nP-pc)<(nG-gc)?'gear':'pulley';
        else kind=gc<nG?'gear':'pulley';
        this.attachments.push({
          kind, u:(idx+1)/(total+1),
          orientation: p.random()<0.5?'horizontal':'vertical',
          radius: this.radius*p.random(1.4,2.2),
          thickness: this.radius*p.random(0.6,1.3),
          teeth: p.floor(p.random(6,14)),
          baseSpeed: p.random([-1,1])*p.random(0.3,1.0),
          phase: p.random(p.TWO_PI)
        });
        if (kind==='gear') gc++; else pc++;
        idx++;
      }
    }
    update() {}
    draw(t) {
      const sE=egoStress, jR=jitter(sE);
      p.push();
      p.translate(this.mid.x+jR.x, this.mid.y+jR.y, this.mid.z+jR.z);
      p.rotateY(this.rotY); p.rotateX(this.rotX); p.noStroke();
      machineFill(this.mid.x, this.mid.y, this.mid.z, 210, 160, 70, t, sE);
      p.cylinder(this.radius, this.length);
      for (const att of this.attachments) {
        const isG=att.kind==='gear';
        const aS=isG?angerStress:attachmentStress;
        const sm=speedMult(aS), yPos=(att.u-0.5)*this.length, jA=jitter(aS);
        p.push();
        p.translate(jA.x, yPos+jA.y, jA.z);
        const rotFn=att.orientation==='horizontal'?p.rotateY.bind(p):p.rotateX.bind(p);
        rotFn(att.phase+att.baseSpeed*sm*t);
        if (isG) {
          machineFill(0,0,0, att.orientation==='horizontal'?15:25, 150, 80, t, aS);
          p.cylinder(att.radius, att.thickness);
          const tD=att.thickness*1.05, tW=(p.TWO_PI*att.radius)/(att.teeth*3.5), tH=att.radius*0.1;
          for (let i=0; i<att.teeth; i++) {
            const a=(p.TWO_PI*i)/att.teeth;
            p.push();
            if (att.orientation==='horizontal') { p.translate(p.cos(a)*att.radius,0,p.sin(a)*att.radius); p.rotateY(a); }
            else { p.translate(0,p.cos(a)*att.radius,p.sin(a)*att.radius); p.rotateX(a); }
            machineFill(0,0,0,30,130,82,t,aS); p.box(tW,tH,tD);
            p.pop();
          }
        } else {
          machineFill(0,0,0,80,130,75,t,aS); p.cylinder(att.radius,att.thickness*0.5);
          p.push(); machineFill(0,0,0,200,90,60,t,aS); p.cylinder(att.radius*0.7,att.thickness*1.1); p.pop();
        }
        p.pop();
      }
      p.pop();
    }
  }

}; // end sketch

new p5(sketch);
</script>

</body>
</html>
